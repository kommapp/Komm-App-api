part of komm.api;

// This file is generated by https://github.com/dart-ogurets/dart-openapi-maven - you should not modify it
// log generation bugs on Github, as part of the license, you must not remove these headers from the Mustache templates.

class ProfileApi {
  final ProfileApiDelegate apiDelegate;

  ProfileApi(ApiClient apiClient) : apiDelegate = ProfileApiDelegate(apiClient);

  Future<void> createProfile({Options? options, required CreateProfileRequest request}) async {
    final response = await apiDelegate.createProfile(
      options: options,
      request: request,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }
  }

  /// Profile Hobbies By Id
  Future<List<String>> getHobbiesByProfileId(String id, {Options? options}) async {
    final response = await apiDelegate.getHobbiesByProfileId(id, options: options);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    if (__body == null) {
      throw ApiException(500, 'Received an empty body (not in a 204)');
    }

    return await apiDelegate.getHobbiesByProfileId_decode(__body);
  }

  /// Profile Pictures By Id
  Future<List<ProfilePicture>> getPicturesByProfileId(String id, {Options? options}) async {
    final response = await apiDelegate.getPicturesByProfileId(
      id,
      options: options,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    if (__body == null) {
      throw ApiException(500, 'Received an empty body (not in a 204)');
    }

    return await apiDelegate.getPicturesByProfileId_decode(__body);
  }

  /// Profile List By User
  Future<List<ProfileInfo>> getProfileList({Options? options}) async {
    final response = await apiDelegate.getProfileList(
      options: options,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    if (__body == null) {
      throw ApiException(500, 'Invalid response received for 204 based API');
    }

    return await apiDelegate.getProfileList_decode(__body);
  }

  /// Profile By Id
  Future<Profile> getProfileById(String id, {Options? options}) async {
    final response = await apiDelegate.getProfileById(
      id,
      options: options,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    if (__body == null) {
      throw ApiException(500, 'Received an empty body (not in a 204)');
    }

    return await apiDelegate.getProfileById_decode(__body);
  }

  /// Update Profile By Id
  Future<void> updateProfileById(String id, Profile profile, {Options? options}) async {
    final response = await apiDelegate.updateProfileById(
      id,
      profile: profile,
      options: options,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    return;
  }

  /// Update Profile Hobbies By Id
  Future<void> updateProfileHobbiesById(String id, List<String> hobbies, {Options? options}) async {
    final response = await apiDelegate.updateProfileHobbiesById(id, hobbies, options: options);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    return;
  }

  /// Update Profile Status By Id
  Future<void> updateProfileStatusById(String id, {Options? options, int? status}) async {
    final response = await apiDelegate.updateProfileStatusById(id, options: options, status: status);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    return;
  }

  /// Update Profile Privacy By Id
  Future<void> updateProfilePrivacyById(String id, {Options? options, int? privacy}) async {
    final response = await apiDelegate.updateProfilePrivacyById(id, options: options, privacy: privacy);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    return;
  }

  /// Upload Profile Images
  Future<void> uploadProfileImages(String profileId, List<Uint8List> pictures, int? main, {Options? options}) async {
    try {
      final response = await apiDelegate.uploadProfileImages(profileId, pictures, main ?? -1, options: options);

      final __body = response.body;
      if (response.statusCode >= 400) {
        throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
      }

      return;
    } catch (e) {
      throw e;
    }
  }

  /// Update Profile Main Picture By Id
  Future<void> updateProfileMainPictureById(String id, String pictureId, {Options? options}) async {
    final response = await apiDelegate.updateProfileMainPictureById(id, pictureId, options: options);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    return;
  }

  /// Delete Profile Picture By Id
  Future<void> deleteProfilePictureById(String pictureId, {Options? options}) async {
    final response = await apiDelegate.deleteProfilePictureById(
      pictureId,
      options: options,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    return;
  }

  /// Get Profile Preferences
  Future<ProfilePreferences> getProfilePreferencesById(String id, {Options? options}) async {
    final response = await apiDelegate.getProfilePreferencesById(
      id,
      options: options,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    if (__body == null) {
      throw ApiException(500, 'Received an empty body (not in a 204)');
    }

    return await apiDelegate.getProfilePreferencesById_decode(__body);
  }

  /// Update Profile Preferences
  Future<void> updateProfilePreferencesById(String id, ProfilePreferences preferences, {Options? options}) async {
    final response =
        await apiDelegate.updateProfilePreferencesById(id, options: options, profilePreferences: preferences);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }
  }

  Future<void> blockProfileGrid({Options? options, BlockProfileGridRequest? blockProfileGridRequest}) async {
    final response =
        await apiDelegate.blockProfileGrid(options: options, blockProfileGridRequest: blockProfileGridRequest);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }
  }

  Future<void> contactKomm({Options? options, ContactKommRequest? contactKommRequest}) async {
    final response = await apiDelegate.contactKomm(options: options, contactKommRequest: contactKommRequest);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }
  }

  Future<ProfileSocialInfo> getSocialInfoByProfileId(String id, {Options? options}) async {
    final response = await apiDelegate.getSocialInfoByProfileId(
      id,
      options: options,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    if (__body == null) {
      throw ApiException(500, 'Received an empty body (not in a 204)');
    }

    return await apiDelegate.getSocialInfoByProfileId_decode(__body);
  }

  Future<void> updateProfileSocialInfoById(String id,
      {Options? options, UpdateProfileSocialInfoByIdRequest? updateProfileSocialInfoByIdRequest}) async {
    final response = await apiDelegate.updateProfileSocialInfoById(id,
        options: options, updateProfileSocialInfoByIdRequest: updateProfileSocialInfoByIdRequest);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }
  }

  Future<void> readNotification(String profileId,
      {Options? options, ReadNotificationRequest? readNotificationRequest}) async {
    final response = await apiDelegate.readNotification(profileId,
        options: options, readNotificationRequest: readNotificationRequest);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    return;
  }

  Future<ProfilePermissions> getProfilePermissionsById(String id, {Options? options}) async {
    final response = await apiDelegate.getProfilePermissionsById(
      id,
      options: options,
    );

    if (![200, 400].contains(response.statusCode)) {
      throw ApiException(500, 'Invalid response code ${response.statusCode} returned from API');
    }

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    if (__body == null) {
      throw ApiException(500, 'Received an empty body (not in a 204)');
    }

    return await apiDelegate.getProfilePermissionsById_decode(__body);
  }
}

class ProfileApiDelegate {
  final ApiClient apiClient;

  ProfileApiDelegate(this.apiClient);

  Future<ApiResponse> createProfile({Options? options, required CreateProfileRequest request}) async {
    // create path and map variables
    final __path = '/profile';

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    if (!headerParams.containsKey('Content-Type')) {
      headerParams['Content-Type'] = 'application/json';
    }

    final postBody = LocalApiClient.serialize(request);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'POST';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> createProfile_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> getHobbiesByProfileId(String id, {Options? options}) async {
    // create path and map variables
    final __path = '/profile/{id}/hobbies'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>["oauth2"];
    final opt = options ?? Options();

    final contentTypes = [];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'GET';

    return await apiClient.invokeAPI(__path, queryParams, null, authNames, opt);
  }

  Future<List<String>> getHobbiesByProfileId_decode(Stream<List<int>> body) async {
    return (LocalApiClient.deserializeFromString(await utf8.decodeStream(body), 'List<String>') as List)
        .map((item) => item as String)
        .toList();
  }

  Future<ApiResponse> getPicturesByProfileId(String id, {Options? options}) async {
    // create path and map variables
    final __path = '/profile/{id}/pictures'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = [];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'GET';

    return await apiClient.invokeAPI(__path, queryParams, null, authNames, opt);
  }

  Future<List<ProfilePicture>> getPicturesByProfileId_decode(Stream<List<int>> body) async {
    return (LocalApiClient.deserializeFromString(await utf8.decodeStream(body), 'List<ProfilePicture>') as List)
        .map((item) => item as ProfilePicture)
        .toList();
  }

  Future<ApiResponse> getProfileList({Options? options}) async {
    // create path and map variables
    final __path = '/profile';

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>["oauth2"];
    final opt = options ?? Options();

    final contentTypes = [];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'GET';

    return await apiClient.invokeAPI(__path, queryParams, null, authNames, opt);
  }

  Future<List<ProfileInfo>> getProfileList_decode(Stream<List<int>> body) async {
    return (LocalApiClient.deserializeFromString(await utf8.decodeStream(body), 'List<ProfileInfo>') as List)
        .map((item) => item as ProfileInfo)
        .toList();
  }

  Future<ApiResponse> getProfileById(String id, {Options? options}) async {
    // create path and map variables
    final __path = '/profile/{id}'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = [];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'GET';

    return await apiClient.invokeAPI(__path, queryParams, null, authNames, opt);
  }

  Future<Profile> getProfileById_decode(Stream<List<int>> body) async {
    return LocalApiClient.deserializeFromString(await utf8.decodeStream(body), 'Profile') as Profile;
  }

  Future<ApiResponse> updateProfileById(String id, {Options? options, required Profile profile}) async {
    // create path and map variables
    final __path = '/profile/{id}'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    if (!headerParams.containsKey('Content-Type')) {
      headerParams['Content-Type'] = 'application/json';
    }

    final postBody = LocalApiClient.serialize(profile);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'PATCH';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> updateProfileById_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> updateProfileHobbiesById(String id, List<String> hobbies, {Options? options}) async {
    // create path and map variables
    final __path = '/profile/{id}/hobbies'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    if (!headerParams.containsKey('Content-Type')) {
      headerParams['Content-Type'] = 'application/json';
    }

    final postBody = jsonEncode(hobbies);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'PATCH';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> updateProfileHobbiesById_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> updateProfileStatusById(String id, {Options? options, int? status}) async {
    // create path and map variables
    final __path = '/profile/{id}/status'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    if (!headerParams.containsKey('Content-Type')) {
      headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
    }
    final postBody = <String, dynamic>{
      'status': LocalApiClient.parameterToString(status),
    }.entries.where((me) => me.value != null).map((me) => me.key + "=" + Uri.encodeComponent(me.value)).join("&");

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'PATCH';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> updateProfileStatusById_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> updateProfilePrivacyById(String id, {Options? options, int? privacy}) async {
    // create path and map variables
    final __path = '/profile/{id}/privacy'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    if (!headerParams.containsKey('Content-Type')) {
      headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
    }
    final postBody = <String, dynamic>{
      'privacy': LocalApiClient.parameterToString(privacy),
    }.entries.where((me) => me.value != null).map((me) => me.key + "=" + Uri.encodeComponent(me.value)).join("&");

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'PATCH';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> updateProfilePrivacyById_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> uploadProfileImages(String profileId, List<Uint8List> pictures, int? main,
      {Options? options}) async {
    // create path and map variables
    final __path = '/profile/upload';

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    if (!headerParams.containsKey('Content-Type')) {
      headerParams['Content-Type'] = 'multipart/form-data';
    }

    List<MultipartFile> files = [];
    var count = 0;
    for (var p in pictures) {
      files.add(MultipartFile.fromBytes(p, filename: "image_$count.jpg"));
    }

    final map = Map.fromEntries(<String, dynamic>{
      'profile_id': LocalApiClient.parameterToString(profileId),
      'main': LocalApiClient.parameterToString(main),
      'picture[]': files
    }.entries.where((m) => m.value != null));

    final postBody = FormData.fromMap(map);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'POST';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<ApiResponse> updateProfileMainPictureById(String id, String pictureId, {Options? options}) async {
    // create path and map variables
    final __path = '/profile/{id}/main/picture'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    if (!headerParams.containsKey('Content-Type')) {
      headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
    }
    final postBody = <String, dynamic>{
      'picture_id': LocalApiClient.parameterToString(pictureId),
    }.entries.where((me) => me.value != null).map((me) => me.key + "=" + Uri.encodeComponent(me.value)).join("&");

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'PATCH';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> updateProfileMainPictureById_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> deleteProfilePictureById(String pictureId, {Options? options}) async {
    // create path and map variables
    final __path = '/profile/picture/{pictureId}'
        .replaceAll('{' + 'pictureId' + '}', LocalApiClient.parameterToString(pictureId)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = [];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'DELETE';

    return await apiClient.invokeAPI(__path, queryParams, null, authNames, opt);
  }

  Future<void> deleteProfilePictureById_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> getProfilePreferencesById(String id, {Options? options}) async {
    // create path and map variables
    final __path = '/profile/{id}/preferences'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = [];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'GET';

    return await apiClient.invokeAPI(__path, queryParams, null, authNames, opt);
  }

  Future<ProfilePreferences> getProfilePreferencesById_decode(Stream<List<int>> body) async {
    return LocalApiClient.deserializeFromString(await utf8.decodeStream(body), 'ProfilePreferences')
        as ProfilePreferences;
  }

  Future<void> uploadProfileImage_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> updateProfilePreferencesById(String id,
      {Options? options, ProfilePreferences? profilePreferences}) async {
    Object? postBody = profilePreferences;

    // create path and map variables
    final __path = '/profile/{id}/preferences'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = ['application/json'];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }
    postBody = postBody == null ? null : LocalApiClient.serialize(postBody);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'PATCH';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> updateProfilePreferencesById_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> blockProfileGrid({Options? options, BlockProfileGridRequest? blockProfileGridRequest}) async {
    Object? postBody = blockProfileGridRequest;

    final __path = '/profile/block/grid';

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = ['application/json'];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }
    postBody = postBody == null ? null : LocalApiClient.serialize(postBody);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'POST';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> blockProfileGrid_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> contactKomm({Options? options, ContactKommRequest? contactKommRequest}) async {
    Object? postBody = contactKommRequest;

    // create path and map variables
    final __path = '/profile/contact';

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = ['application/json'];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }
    postBody = postBody == null ? null : LocalApiClient.serialize(postBody);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'POST';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> contactKomm_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> getSocialInfoByProfileId(String id, {Options? options}) async {
    // create path and map variables
    final __path = '/profile/{id}/social'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = [];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'GET';

    return await apiClient.invokeAPI(__path, queryParams, null, authNames, opt);
  }

  Future<ProfileSocialInfo> getSocialInfoByProfileId_decode(Stream<List<int>> body) async {
    return LocalApiClient.deserializeFromString(await utf8.decodeStream(body), 'ProfileSocialInfo')
        as ProfileSocialInfo;
  }

  Future<ApiResponse> updateProfileSocialInfoById(String id,
      {Options? options, UpdateProfileSocialInfoByIdRequest? updateProfileSocialInfoByIdRequest}) async {
    Object? postBody = updateProfileSocialInfoByIdRequest;

    // create path and map variables
    final __path = '/profile/{id}/social'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = ['application/json'];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }
    postBody = postBody == null ? null : LocalApiClient.serialize(postBody);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'PATCH';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> updateProfileSocialInfoById_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> readNotification(String profileId,
      {Options? options, ReadNotificationRequest? readNotificationRequest}) async {
    Object? postBody = readNotificationRequest;

    // create path and map variables
    final __path = '/profile/{profileId}/read-notification'
        .replaceAll('{' + 'profileId' + '}', LocalApiClient.parameterToString(profileId)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = ['application/json'];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }
    postBody = postBody == null ? null : LocalApiClient.serialize(postBody);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'PATCH';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> readNotification_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> getProfilePermissionsById(String id, {Options? options}) async {
    // create path and map variables
    final __path = '/profile/{id}/permissions'.replaceAll('{' + 'id' + '}', LocalApiClient.parameterToString(id)!);

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>['oauth2'];
    final opt = options ?? Options();

    final contentTypes = [];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'GET';

    return await apiClient.invokeAPI(__path, queryParams, null, authNames, opt);
  }

  Future<ProfilePermissions> getProfilePermissionsById_decode(Stream<List<int>> body) async {
    return LocalApiClient.deserializeFromString(await utf8.decodeStream(body), 'ProfilePermissions')
        as ProfilePermissions;
  }
}
