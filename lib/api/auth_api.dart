part of komm.api;

// This file is generated by https://github.com/dart-ogurets/dart-openapi-maven - you should not modify it
// log generation bugs on Github, as part of the license, you must not remove these headers from the Mustache templates.

class AuthApi {
  final AuthApiDelegate apiDelegate;
  AuthApi(ApiClient apiClient) : apiDelegate = AuthApiDelegate(apiClient);

  Future<RequestTokenResponse> getAuthToken(
      {Options? options,
      String? grantType,
      String? refreshToken,
      String? clientId,
      String? clientSecret,
      String? scope,
      String? username,
      String? password}) async {
    final response = await apiDelegate.getAuthToken(
        options: options,
        grantType: grantType,
        refreshToken: refreshToken,
        clientId: clientId,
        clientSecret: clientSecret,
        scope: scope,
        username: username,
        password: password);

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    if (__body == null) {
      throw ApiException(500, 'Received an empty body (not in a 204)');
    }

    return await apiDelegate.getAuthToken_decode(__body);
  }

  Future<void> recoverPasswordChange(RecoverPasswordChangeRequest recoverPasswordChangeRequest,
      {Options? options}) async {
    final response = await apiDelegate.recoverPasswordChange(
      recoverPasswordChangeRequest,
      options: options,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    return;
  }

  Future<void> recoverPasswordRequest(RecoverPasswordRequestRequest recoverPasswordRequest, {Options? options}) async {
    final response = await apiDelegate.recoverPasswordRequest(
      recoverPasswordRequest,
      options: options,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    return;
  }

  Future<RecoverPasswordValidResponse> recoverPasswordValid(RecoverPasswordValidRequest recoverPasswordValidRequest,
      {Options? options}) async {
    final response = await apiDelegate.recoverPasswordValid(
      recoverPasswordValidRequest,
      options: options,
    );

    final __body = response.body;
    if (response.statusCode >= 400) {
      throw ApiException(response.statusCode, __body == null ? null : await decodeBodyBytes(__body));
    }

    if (__body == null) {
      throw ApiException(500, 'Received an empty body (not in a 204)');
    }

    return await apiDelegate.recoverPasswordValid_decode(__body);
  }
}

class AuthApiDelegate {
  final ApiClient apiClient;

  AuthApiDelegate(this.apiClient);

  Future<ApiResponse> getAuthToken(
      {Options? options,
      String? grantType,
      String? refreshToken,
      String? clientId,
      String? clientSecret,
      String? scope,
      String? username,
      String? password}) async {
    // create path and map variables
    final __path = '/oauth/token';

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>[];
    final opt = options ?? Options();

    if (!headerParams.containsKey('Content-Type')) {
      headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
    }
    final postBody = <String, dynamic>{
      'grant_type': LocalApiClient.parameterToString(grantType),
      'refresh_token': LocalApiClient.parameterToString(refreshToken),
      'client_id': LocalApiClient.parameterToString(clientId),
      'client_secret': LocalApiClient.parameterToString(clientSecret),
      'scope': LocalApiClient.parameterToString(scope),
      'username': LocalApiClient.parameterToString(username),
      'password': LocalApiClient.parameterToString(password),
    }.entries.where((me) => me.value != null).map((me) => me.key + "=" + Uri.encodeComponent(me.value)).join("&");

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'POST';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<RequestTokenResponse> getAuthToken_decode(Stream<List<int>> body) async {
    return LocalApiClient.deserializeFromString(await utf8.decodeStream(body), 'RequestTokenResponse')
        as RequestTokenResponse;
  }

  Future<ApiResponse> recoverPasswordChange(RecoverPasswordChangeRequest recoverPasswordChangeRequest,
      {Options? options}) async {
    Object postBody = recoverPasswordChangeRequest;

    // create path and map variables
    final __path = '/recovery-password';

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>[];
    final opt = options ?? Options();

    final contentTypes = ['application/json'];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }
    postBody = LocalApiClient.serialize(postBody);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'POST';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> recoverPasswordChange_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> recoverPasswordRequest(RecoverPasswordRequestRequest recoverPasswordRequest, {Options? options}) async {
    Object postBody = recoverPasswordRequest;

    // create path and map variables
    final __path = '/recovery-password-request';

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>[];
    final opt = options ?? Options();

    final contentTypes = ['application/json'];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }
    postBody = LocalApiClient.serialize(postBody);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'POST';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<void> recoverPasswordRequest_decode(Stream<List<int>> body) async {}

  Future<ApiResponse> recoverPasswordValid(RecoverPasswordValidRequest recoverPasswordValidRequest,
      {Options? options}) async {
    Object postBody = recoverPasswordValidRequest;

    // create path and map variables
    final __path = '/recovery-password-valid';

    // query params
    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{}..addAll(options?.headers?.cast<String, String>() ?? {});
    if (!headerParams.containsKey('Accept')) {
      // we only want to accept this format as we can parse it
      headerParams['Accept'] = 'application/json';
    }

    final authNames = <String>[];
    final opt = options ?? Options();

    final contentTypes = ['application/json'];

    if (contentTypes.isNotEmpty && headerParams['Content-Type'] == null) {
      headerParams['Content-Type'] = contentTypes[0];
    }
    postBody = LocalApiClient.serialize(postBody);

    headerParams.removeWhere((key, value) => value.isEmpty); // remove empty headers
    opt.headers = headerParams;
    opt.method = 'POST';

    return await apiClient.invokeAPI(__path, queryParams, postBody, authNames, opt);
  }

  Future<RecoverPasswordValidResponse> recoverPasswordValid_decode(Stream<List<int>> body) async {
    return LocalApiClient.deserializeFromString(await utf8.decodeStream(body), 'RecoverPasswordValidResponse')
        as RecoverPasswordValidResponse;
  }
}
